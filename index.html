<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Squat Form Coach</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js" crossorigin="anonymous"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            font-family: Arial, sans-serif;
            color: white;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        video {
            display: none;
        }
        
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        #stats {
            position: absolute;
            top: 60px;
            left: 30px;
            z-index: 10;
            text-shadow: 2px 2px 4px #000;
        }
        
        #reps {
            font-size: 60px;
            font-weight: bold;
        }
        
        #angle {
            font-size: 30px;
            color: #ccc;
        }
        
        #feedback {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 70px;
            font-weight: bold;
            text-shadow: 3px 3px 6px #000;
            z-index: 10;
        }
        
        .good { color: #0f0; }
        .warn { color: #fa0; }
        .bad { color: #f00; }
        
        button {
            position: absolute;
            bottom: 30px;
            padding: 15px 30px;
            font-size: 18px;
            background: #f00;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            z-index: 10;
        }
        
        button:hover {
            background: #f33;
        }
        
        #reset { right: 30px; }
        #quit { right: 150px; }
        
        #instructions {
            position: absolute;
            top: 20px;
            left: 0;
            right: 0;
            text-align: center;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            font-size: 16px;
            z-index: 10;
        }
        @media (max-width: 768px) {
            button {
                bottom: 20px;
                padding: 12px 24px;
                font-size: 16px;
            }
            
            #reset { right: 20px; }
            #quit { right: 130px; }
            
            #reps { font-size: 48px; }
            #angle { font-size: 24px; }
            #feedback { font-size: 50px; }
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="instructions">Stand SIDEWAYS • R = Reset • Q = Quit</div>
        <video id="video" autoplay playsinline></video>
        <canvas id="canvas"></canvas>
        <div id="stats">
            <div id="reps">0</div>
            <div id="angle">--°</div>
        </div>
        <div id="feedback"></div>
        <button id="reset">RESET</button>
        <button id="quit">QUIT</button>
    </div>

    <script>
        const video = document.getElementById('video');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const repsEl = document.getElementById('reps');
        const angleEl = document.getElementById('angle');
        const feedbackEl = document.getElementById('feedback');

        let repCount = 0;
        let stage = null;
        let isReady = false;
        let readyTimer = null;

        function calculateAngle(a, b, c) {
            const radians = Math.atan2(c.y - b.y, c.x - b.x) - Math.atan2(a.y - b.y, a.x - b.x);
            let angle = Math.abs(radians * 180.0 / Math.PI);
            return angle > 180.0 ? 360 - angle : angle;
        }

        function detectView(landmarks) {
            const nose = landmarks[0];
            const leftShoulder = landmarks[11];
            const rightShoulder = landmarks[12];
            
            if (!nose || !leftShoulder || !rightShoulder) return 'unclear';
            
            const shoulderWidth = Math.abs(leftShoulder.x - rightShoulder.x);
            if (shoulderWidth < 0.1) {
                return leftShoulder.visibility > rightShoulder.visibility ? 'side_left' : 'side_right';
            }
            
            const shoulderCenter = (leftShoulder.x + rightShoulder.x) / 2;
            const noseOffset = Math.abs(nose.x - shoulderCenter);
            return noseOffset < shoulderWidth * 0.3 ? 'front' : 'side_left';
        }

        function playBeep() {
            try {
                const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioCtx.createOscillator();
                const gainNode = audioCtx.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioCtx.destination);
                oscillator.frequency.value = 1500;
                oscillator.type = 'sine';
                gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
                oscillator.start();
                oscillator.stop(audioCtx.currentTime + 0.1);
            } catch(e) {}
        }

        function onResults(results) {
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;

            ctx.save();
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(results.image, 0, 0, canvas.width, canvas.height);

            if (results.poseLandmarks) {
                const landmarks = results.poseLandmarks;
                const view = detectView(landmarks);

                // Draw skeleton
                drawConnectors(ctx, landmarks, POSE_CONNECTIONS, {color: 'rgba(255,255,255,0.3)', lineWidth: 2});

                if (view === 'side_left' || view === 'side_right') {
                    const idx = view === 'side_left' ? [23, 25, 27] : [24, 26, 28];
                    const hip = landmarks[idx[0]];
                    const knee = landmarks[idx[1]];
                    const ankle = landmarks[idx[2]];

                    if (hip?.visibility > 0.3 && knee?.visibility > 0.3 && ankle?.visibility > 0.3) {
                        // Draw key points
                        ctx.fillStyle = '#0f0';
                        [hip, knee, ankle].forEach(p => {
                            ctx.beginPath();
                            ctx.arc(p.x * canvas.width, p.y * canvas.height, 8, 0, 2 * Math.PI);
                            ctx.fill();
                        });

                        const angle = calculateAngle(hip, knee, ankle);
                        angleEl.textContent = Math.round(angle) + '°';

                        // READY SEQUENCE - must stand still for 2 seconds
                        if (!isReady) {
                            if (angle > 165 && angle < 180) {
                                if (!readyTimer) {
                                    readyTimer = setTimeout(() => { 
                                        isReady = true;
                                    }, 2000);
                                }
                            } else {
                                if (readyTimer) {
                                    clearTimeout(readyTimer);
                                    readyTimer = null;
                                }
                            }
                            
                            feedbackEl.textContent = 'STAND STILL (2s)';
                            feedbackEl.className = '';
                        } else {
                            // REP COUNTING (only after ready)
                            // REP COUNTING (only after ready)
                            if (angle > 160) {
                                stage = 'up';
                            }

                            // Count rep if below 100° (slightly more lenient than 95°)
                            if (angle < 100 && stage === 'up') {
                                stage = 'down';
                                repCount++;
                                repsEl.textContent = repCount;
                            }

                            // FEEDBACK
                            if (angle < 95) {
                                feedbackEl.textContent = 'GOOD DEPTH!';
                                feedbackEl.className = 'good';
                                if (stage === 'down') playBeep();
                            } else if (angle < 100) {
                                feedbackEl.textContent = 'ALMOST!';  // Still counts
                                feedbackEl.className = 'warn';
                            } else if (angle < 120) {
                                feedbackEl.textContent = 'GO DEEPER';  // Doesn't count
                                feedbackEl.className = 'warn';
                            } else {
                                feedbackEl.textContent = '';
                            }
                        }
                    } else {
                        feedbackEl.textContent = 'BODY IN FRAME';
                        feedbackEl.className = 'bad';
                    }
                } else if (view === 'front') {
                    feedbackEl.textContent = 'TURN SIDEWAYS';
                    feedbackEl.className = 'bad';
                }
            }

            ctx.restore();
        }

        function reset() {
            repCount = 0;
            stage = null;
            isReady = false;
            clearTimeout(readyTimer);
            readyTimer = null;
            repsEl.textContent = '0';
            angleEl.textContent = '--°';
            feedbackEl.textContent = '';
        }

        function quit() {
            video.srcObject?.getTracks().forEach(t => t.stop());
            document.body.innerHTML = '<div style="display:flex;align-items:center;justify-content:center;height:100vh;font-size:32px;color:white">Session ended</div>';
        }

        document.getElementById('reset').onclick = reset;
        document.getElementById('quit').onclick = quit;
        document.addEventListener('keydown', e => {
            if (e.key === 'r' || e.key === 'R') reset();
            if (e.key === 'q' || e.key === 'Q') quit();
        });

        const pose = new Pose({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`
        });

        pose.setOptions({
            modelComplexity: 1,
            smoothLandmarks: true,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        pose.onResults(onResults);

        const camera = new Camera(video, {
            onFrame: async () => {
                await pose.send({image: video});
            },
            width: 1280,
            height: 720
        });

        camera.start();
    </script>
</body>
</html>